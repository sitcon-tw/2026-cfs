---
import Popup from "../Popup.astro";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";
import { X, Plus, Minus } from "@lucide/astro";
import plansData from "@data/plans_data.json";

import type { SubItem } from "../../utils/items-loader";

const { item, t, popupId } = Astro.props;

const locale = Astro.currentLocale || "zh-Hant";

const markdownFiles = import.meta.glob<{ Content: any }>("../../data/items/**/*.md", { eager: true });

// Try to load markdown content for this item
let MarkdownContent = null;
let hasMarkdownContent = false;

const markdownPath = `../../data/items/${item.id}/${locale}.md`;

const markdownModule = markdownFiles[markdownPath];

if (markdownModule && markdownModule.Content) {
	MarkdownContent = markdownModule.Content;
	hasMarkdownContent = true;
} else {
	hasMarkdownContent = false;
}

// Import images dynamically using import.meta.glob
const images = import.meta.glob<{ default: ImageMetadata }>("../../assets/img/items/*");
const imagePath = `../../assets/img/items/${item.image}`;

// Find the matching plan row for this item
const planRow = plansData.rows.find(row => row.id === item.id);
const shouldShowPlanTiers = planRow !== undefined;
---

<Popup id={popupId || `plan-popup-${item.id}`} button={false} hero={false}>
	<div class="popup-content" data-item-id={item.id}>
		<div class="item-details">
			<div class="item-meta">
				<span class="remaining" data-initial-remaining={item.remaining} data-unit={t.unit[item.unit] || item.unit}>{t.remaining} {item.remaining} {t.unit[item.unit] || item.unit}</span>
				<span class="category">{`${new Date(item.deadline).getMonth() + 1}/${new Date(item.deadline).getDate()}`} {t.deadline}</span>
			</div>
			<div class="title-row">
				<h3>{item.name}</h3>
				{
					!(item.sub && item.sub.length > 0) && (
						<div class="quantity-controls" data-item-id={item.id} data-quantity={item.quantity} data-remaining={item.remaining}>
							<button type="button" class="quantity-btn minus">
								<Minus />
							</button>
							<span class="quantity-display">0</span>
							<button type="button" class="quantity-btn plus">
								<Plus />
							</button>
						</div>
					)
				}
			</div>
			<div class="item-price">
				<span class="price-value">{item.price}</span>
			</div>

			{
				item.sub && item.sub.length > 0 && (
					<div class="sub-items-section">
						<div class="sub-items-list">
							{item.sub.map((subItem: SubItem, index: number) => {
								const subItemId = `${item.id}-sub-${index}`;

								return (
									<div class="sub-item" data-sub-item-id={subItemId}>
										<span class="sub-item-name">{subItem.name}</span>
										<span class="sub-item-price">{subItem.price}</span>
										<div
											class="sub-item-controls"
											data-item-id={item.id}
											data-sub-item-id={subItemId}
											data-sub-item-name={subItem.name}
											data-sub-item-remaining={subItem.remaining || ""}
											data-initial-sub-item-remaining={subItem.remaining || ""}
										>
											<button type="button" class="sub-quantity-btn minus">
												<Minus size={12} />
											</button>
											<span class="sub-quantity-display">0</span>
											<button type="button" class="sub-quantity-btn plus">
												<Plus size={12} />
											</button>
										</div>
									</div>
								);
							})}
						</div>
					</div>
				)
			}

			{
				shouldShowPlanTiers && planRow && (
					<div class="plan-tiers">
						{plansData.tiers.map((tier, index) => {
							const value = planRow.values[index];
							let displayText = "0";
							let unit = "";

							if (value.textKey === "not_available") {
								displayText = "0";
							} else if ("number" in value && value.number !== undefined) {
								displayText = value.number.toString();
								if ("unitKey" in value && value.unitKey) {
									// Follow the same pattern as Plans.astro - use only the last part of unitKey
									const unitKey = value.unitKey.split(".").pop();
									unit = unitKey ? t.unit[unitKey] || "" : "";
								}
							} else if ("icon" in value && value.icon !== undefined) {
								displayText = value.icon.toString();
								// For icon values, we can use a default unit if needed
								unit = "個"; // or whatever unit makes sense for icons
							} else {
								// For other types (main, textKey that aren't not_available), don't show anything
								displayText = "0";
							}

							return (
								<div class="tier-item" style={`color: ${tier.textColor}`}>
									<span class="tier-name">{t.tier_names[tier.name]}</span>
									<span class="tier-arrow">→</span>
									{displayText === "0" ? (
										<span class="tier-value tier-unavailable">
											<X size={20} />
										</span>
									) : (
										<span class="tier-value">
											{displayText} {unit}
										</span>
									)}
								</div>
							);
						})}
					</div>
				)
			}

			<div class="structured-descriptions">
				{
					item.global_description && (
						<>
							<p>{item.global_description}</p>
						</>
					)
				}

				{
					item.talent_recruitment && (
						<>
							<h2>{t.item_categories.talent_recruitment}</h2>
							<p>{item.talent_recruitment}</p>
						</>
					)
				}

				{
					item.brand_exposure && (
						<>
							<h2>{t.item_categories.brand_exposure}</h2>
							<p>{item.brand_exposure}</p>
						</>
					)
				}

				{
					item.product_promotion && (
						<>
							<h2>{t.item_categories.product_promotion}</h2>
							<p>{item.product_promotion}</p>
						</>
					)
				}
			</div>

			{
				hasMarkdownContent && (
					<div class="markdown-content">
						<MarkdownContent />
					</div>
				)
			}
		</div>
		<div class="item-image">
			{images[imagePath] ? <Image src={images[imagePath]()} alt={item.image_description || item.name} /> : <img src={item.image} alt={item.image_description || item.name} />}
		</div>
	</div>
</Popup>

<style is:global>
	.popup-content {
		padding: 2rem 0;
		display: grid;
		grid-template-columns: 1fr;
		gap: 2rem;
		height: calc(100vh - 6.2rem);
		min-height: 600px;
	}

	/* Desktop and tablet layout */
	@media (min-width: 769px) {
		.popup-content {
			grid-template-columns: 2fr 3fr;
			gap: 0;
			padding: 0;
		}
	}

	.item-details {
		padding: 2rem 3rem;
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		overflow-y: auto;
		height: 100%;
	}

	.title-row {
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 1rem;
	}

	.item-details h3 {
		font-size: 2.5rem;
		color: var(--black);
		margin: 0;
		font-weight: 700;
		flex: 1;
	}

	.item-description {
		font-size: 1.2rem;
		line-height: 1.6;
		color: var(--black);
		margin-bottom: 1.5rem;
	}

	.price-value {
		font-size: 1.4rem;
		color: var(--black);
		font-weight: 700;
		font-family: "Fira Mono", monospace;
		display: block;
		margin: 1.5rem 0rem;
	}

	.quantity-controls {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.quantity-btn {
		width: 2rem;
		aspect-ratio: 1 / 1;
		border-radius: 50%;
		background-color: var(--black);
		color: var(--white);
		border: none;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 1.2rem;
		font-weight: 400;
		transition: transform 0.2s ease;
		line-height: 1;
	}

	.quantity-btn:hover {
		transform: scale(1.1);
	}

	.quantity-btn:disabled {
		opacity: 0.3;
		cursor: not-allowed;
	}

	.quantity-btn:disabled:hover {
		transform: scale(1);
	}

	.quantity-display {
		font-size: 1.2rem;
		font-weight: 600;
		color: var(--black);
		min-width: 1.5rem;
		text-align: center;
	}

	.item-meta {
		display: flex;
		gap: 1rem;
		align-items: center;
		margin-bottom: 1rem;
	}

	.remaining {
		background-color: #f6d46c;
		padding: 0.1rem 0.7rem;
		border-radius: 20px;
		font-size: 0.9rem;
		font-weight: 500;
	}

	.category {
		background-color: #69f147;
		padding: 0.1rem 0.7rem;
		border-radius: 20px;
		font-size: 0.9rem;
		font-weight: 500;
	}

	.item-image {
		display: flex;
		align-items: center;
		justify-content: center;
		overflow: hidden;
		order: 1;
	}

	.item-details {
		order: 2;
	}

	.item-image img {
		width: 100%;
		height: 100%;
		object-fit: cover;
		border-radius: 0;
	}

	/* Desktop and tablet image styles */
	@media (min-width: 769px) {
		.item-image {
			height: 100%;
			order: 0;
		}

		.item-details {
			order: 0;
		}

		.item-image img {
			border-radius: 0 25px 25px 0;
		}
	}

	.plan-tiers {
		margin: 1rem 0;
		padding: 0;
	}

	.tier-item {
		display: flex;
		align-items: center;
		margin-bottom: 0.8rem;
		font-size: 1.3rem;
		font-weight: 600;
	}

	.tier-item:last-child {
		margin-bottom: 0;
	}

	.tier-name {
		font-weight: 700;
		font-size: 1.4rem;
	}

	.tier-arrow {
		margin: 0 1.5rem;
		font-weight: 700;
		opacity: 0.7;
		font-size: 1.3rem;
	}

	.tier-value {
		font-weight: 700;
		font-size: 1.5rem;
	}

	.tier-unavailable {
		display: flex;
		align-items: center;
		justify-content: center;
		opacity: 0.6;
	}

	.tier-unavailable svg {
		width: 24px;
		height: 24px;
	}

	.sub-items-section {
		margin: 1.5rem 0;
		padding-top: 0;
	}

	.sub-items-section h4 {
		font-size: 2rem;
		margin-bottom: 1rem;
		font-weight: 700;
		color: var(--black);
	}

	.sub-items-list {
		display: flex;
		flex-direction: column;
		gap: 0.75rem;
	}

	.sub-item {
		display: flex;
		align-items: center;
		flex-wrap: wrap;
		padding: 0;
		gap: 1rem;
		font-family: "Fira Mono", monospace;
	}

	.sub-item-name {
		font-size: 1.8rem;
		font-weight: 700;
		color: var(--black);
		flex: 0 0 auto;
	}

	.sub-item-price {
		color: rgba(0, 0, 0, 0.6);
		font-weight: 400;
		font-size: 1.3rem;
		flex: 0 0 auto;
	}

	.sub-item-controls {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.sub-quantity-btn {
		width: 1.5rem;
		aspect-ratio: 1 / 1;
		border-radius: 50%;
		background-color: #45454c;
		color: var(--white);
		border: none;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 1rem;
		font-weight: 400;
		transition: transform 0.2s ease;
		line-height: 1;
		padding: 0;
	}

	.sub-quantity-btn svg {
		display: block;
	}

	.sub-quantity-btn:hover {
		transform: scale(1.1);
	}

	.sub-quantity-btn:disabled {
		opacity: 0.3;
		cursor: not-allowed;
	}

	.sub-quantity-btn:disabled:hover {
		transform: scale(1);
	}

	.sub-quantity-display {
		font-size: 1rem;
		font-weight: 600;
		color: var(--black);
		min-width: 1.5rem;
		text-align: center;
	}

	.structured-descriptions h2 {
		font-size: 1.5rem;
		margin-bottom: 0.5rem;
		margin-top: 1.5rem;
		text-align: left;
	}

	.structured-descriptions h2:first-child {
		margin-top: 0;
	}

	@media (max-width: 768px) {
		.popup-content {
			padding: 1.5rem 0;
			gap: 2rem;
			height: auto;
		}

		.item-details {
			padding: 0 2rem;
		}

		.item-details h3 {
			font-size: 2rem;
		}

		.item-image {
			height: 250px;
			margin: 0 2rem;
		}

		.item-image img {
			border-radius: 15px;
		}

		.plan-tiers {
			margin: 0.8rem 0;
			padding: 0;
		}

		.tier-item {
			font-size: 1.1rem;
			margin-bottom: 0.6rem;
		}

		.tier-arrow {
			font-size: 1.1rem;
			margin: 0 1rem;
		}

		.tier-value {
			font-size: 1.3rem;
		}

		.tier-unavailable svg {
			width: 20px;
			height: 20px;
		}

		.sub-items-section {
			margin: 1rem 0;
		}

		.sub-items-section h4 {
			font-size: 1.1rem;
		}

		.sub-item {
			align-items: center;
			gap: 1rem;
		}

		.sub-item-name {
			font-size: 1.2rem;
		}

		.sub-item-price {
			font-size: 1rem;
		}
	}
</style>

<script>
	import { addInterestedItem, removeInterestedItem, updateItemQuantity, getItemQuantity } from "../../utils/local-storage.ts";

	document.addEventListener("DOMContentLoaded", function () {
		// Parse quantity from item.quantity field (e.g., "max 5", "不限", "獨家", "打包專屬")
		function parseQuantityLimit(quantityStr: string): number | null {
			if (!quantityStr) return null;
			if (quantityStr === "不限") return null; // unlimited

			const match = quantityStr.match(/max\s+(\d+)/i);
			if (match) return parseInt(match[1], 10);

			return null;
		}

		// Update remaining badge for items WITHOUT sub-items
		function updateRemainingBadge(itemId: string) {
			const popup = document.querySelector(`.popup-content[data-item-id="${itemId}"]`);
			if (!popup) return;

			const remainingBadge = popup.querySelector(".remaining") as HTMLElement;
			if (!remainingBadge) return;

			const initialRemaining = parseInt(remainingBadge.getAttribute("data-initial-remaining") || "0", 10);
			const unit = remainingBadge.getAttribute("data-unit") || "";
			const currentQty = getItemQuantity(itemId) || 0;

			const newRemaining = Math.max(0, initialRemaining - currentQty);

			// Extract the translation text (e.g., "剩餘" or "Remaining")
			const remainingText = remainingBadge.textContent?.split(" ")[0] || "";
			remainingBadge.textContent = `${remainingText} ${newRemaining} ${unit}`;
		}

		// Update remaining badge for items WITH sub-items
		function updateRemainingBadgeForParentWithSubs(itemId: string) {
			const popup = document.querySelector(`.popup-content[data-item-id="${itemId}"]`);
			if (!popup) return;

			const remainingBadge = popup.querySelector(".remaining") as HTMLElement;
			if (!remainingBadge) return;

			const unit = remainingBadge.getAttribute("data-unit") || "";

			// Get all sub-item controls for this parent item
			const subItemControls = popup.querySelectorAll(`.sub-item-controls[data-item-id="${itemId}"]`);

			let totalInitialRemaining = 0;
			let totalSelectedQuantity = 0;

			subItemControls.forEach(controls => {
				const initialRemaining = parseInt(controls.getAttribute("data-initial-sub-item-remaining") || "0", 10);
				totalInitialRemaining += initialRemaining;

				const subItemId = controls.getAttribute("data-sub-item-id") || "";
				const selectedQty = getItemQuantity(subItemId) || 0;
				totalSelectedQuantity += selectedQty;
			});

			const newRemaining = Math.max(0, totalInitialRemaining - totalSelectedQuantity);

			// Extract the translation text (e.g., "剩餘" or "Remaining")
			const remainingText = remainingBadge.textContent?.split(" ")[0] || "";
			remainingBadge.textContent = `${remainingText} ${newRemaining} ${unit}`;
		}

		// Sync quantity controls with localStorage
		function syncQuantityControls(itemId: string) {
			const controls = document.querySelector(`.quantity-controls[data-item-id="${itemId}"]`) as HTMLElement;
			if (!controls) return;

			const display = controls.querySelector(".quantity-display") as HTMLElement;
			const minusBtn = controls.querySelector(".quantity-btn.minus") as HTMLButtonElement;
			const plusBtn = controls.querySelector(".quantity-btn.plus") as HTMLButtonElement;

			const currentQty = getItemQuantity(itemId) || 0;
			if (display) display.textContent = currentQty.toString();

			// Get max quantity from data attributes
			const quantityStr = controls.getAttribute("data-quantity") || "";
			const remainingStr = controls.getAttribute("data-remaining") || "";

			// Parse both limits
			const maxPerOrder = parseQuantityLimit(quantityStr);
			const remaining = parseInt(remainingStr, 10);

			// Calculate effective max: min of remaining and max per order
			let maxQuantity: number | null = null;
			if (!isNaN(remaining)) {
				maxQuantity = remaining;
				if (maxPerOrder !== null && maxPerOrder < remaining) {
					maxQuantity = maxPerOrder;
				}
			} else if (maxPerOrder !== null) {
				maxQuantity = maxPerOrder;
			}

			// Disable plus button if at max quantity
			if (maxQuantity !== null && plusBtn) {
				plusBtn.disabled = currentQty >= maxQuantity;
			} else if (plusBtn) {
				plusBtn.disabled = false;
			}

			// Disable minus button if at 0
			if (minusBtn) {
				minusBtn.disabled = currentQty <= 0;
			}

			// Update remaining badge for regular items
			updateRemainingBadge(itemId);
		}

		// Sync sub-item quantity controls with localStorage (treats sub-items as regular items)
		function syncSubItemControls(subItemId: string) {
			const controls = document.querySelector(`.sub-item-controls[data-sub-item-id="${subItemId}"]`) as HTMLElement;
			if (!controls) return;

			const display = controls.querySelector(".sub-quantity-display") as HTMLElement;
			const minusBtn = controls.querySelector(".sub-quantity-btn.minus") as HTMLButtonElement;
			const plusBtn = controls.querySelector(".sub-quantity-btn.plus") as HTMLButtonElement;

			const currentQty = getItemQuantity(subItemId) || 0;
			if (display) display.textContent = currentQty.toString();

			// Get max quantity from data attribute (sub-item remaining is just a number or "max X" format)
			const remainingStr = controls.getAttribute("data-sub-item-remaining") || "";
			let maxQuantity: number | null = null;

			// Try parsing as a direct number first
			const directNum = parseInt(remainingStr, 10);
			if (!isNaN(directNum)) {
				maxQuantity = directNum;
			} else {
				// Try parsing "max X" format
				maxQuantity = parseQuantityLimit(remainingStr);
			}

			// Disable plus button if at max quantity
			if (maxQuantity !== null && plusBtn) {
				plusBtn.disabled = currentQty >= maxQuantity;
			} else if (plusBtn) {
				plusBtn.disabled = false;
			}

			// Disable minus button if at 0
			if (minusBtn) {
				minusBtn.disabled = currentQty <= 0;
			}

			// Update remaining badge for parent item with sub-items
			const parentItemId = controls.getAttribute("data-item-id");
			if (parentItemId) {
				updateRemainingBadgeForParentWithSubs(parentItemId);
			}
		}

		// Handle quantity controls
		document.addEventListener("click", function (e) {
			const target = e.target as Element;

			// Sub-item Plus button (treat sub-items as regular items)
			if (target.closest(".sub-quantity-btn.plus")) {
				console.log("Sub-item plus button clicked!");
				e.preventDefault();
				e.stopPropagation();

				const btn = target.closest(".sub-quantity-btn.plus") as HTMLButtonElement;
				const controls = btn.closest(".sub-item-controls");
				console.log("controls:", controls);
				if (!controls) return;

				const subItemId = controls.getAttribute("data-sub-item-id");
				console.log("subItemId:", subItemId);
				if (!subItemId) return;

				const currentQty = getItemQuantity(subItemId) || 0;
				const newQty = currentQty + 1;
				console.log("currentQty:", currentQty, "newQty:", newQty);

				if (currentQty === 0) {
					// Get item data from popup (same as regular item)
					const popup = controls.closest(".popup-content");
					const subItemName = controls.getAttribute("data-sub-item-name") || "";
					const img = popup?.querySelector(".item-image img");
					const itemImage = img?.getAttribute("src") || "";
					const deadlineEl = popup?.querySelector(".category");
					const itemDeadline = deadlineEl?.textContent || "";

					// Parse max quantity from data attribute (sub-item remaining is just a number or "max X" format)
					const remainingStr = controls.getAttribute("data-sub-item-remaining") || "";
					let maxQuantity: number | null = null;

					// Try parsing as a direct number first
					const directNum = parseInt(remainingStr, 10);
					if (!isNaN(directNum)) {
						maxQuantity = directNum;
					} else {
						// Try parsing "max X" format
						maxQuantity = parseQuantityLimit(remainingStr);
					}

					console.log("Adding sub-item to cart:", {
						id: subItemId,
						title: subItemName,
						image: itemImage,
						deadline: itemDeadline,
						maxQuantity: maxQuantity
					});

					// Add item to cart with quantity 1
					addInterestedItem({
						id: subItemId,
						title: subItemName,
						category: "all",
						image: itemImage,
						deadline: itemDeadline,
						quantity: 1,
						maxQuantity: maxQuantity
					});
				} else {
					// Update existing quantity
					console.log("Updating sub-item quantity:", subItemId, newQty);
					updateItemQuantity(subItemId, newQty);
				}

				syncSubItemControls(subItemId);
			}

			// Sub-item Minus button (treat sub-items as regular items)
			if (target.closest(".sub-quantity-btn.minus")) {
				e.preventDefault();
				e.stopPropagation();

				const btn = target.closest(".sub-quantity-btn.minus") as HTMLButtonElement;
				const controls = btn.closest(".sub-item-controls");
				if (!controls) return;

				const subItemId = controls.getAttribute("data-sub-item-id");
				if (!subItemId) return;

				const currentQty = getItemQuantity(subItemId) || 0;
				if (currentQty <= 0) return;

				const newQty = currentQty - 1;

				if (newQty === 0) {
					// Remove from cart when quantity reaches 0
					removeInterestedItem(subItemId);
				} else {
					updateItemQuantity(subItemId, newQty);
				}

				syncSubItemControls(subItemId);
			}

			// Plus button
			if (target.closest(".quantity-btn.plus")) {
				e.preventDefault();
				e.stopPropagation();

				const btn = target.closest(".quantity-btn.plus") as HTMLButtonElement;
				const controls = btn.closest(".quantity-controls");
				if (!controls) return;

				const itemId = controls.getAttribute("data-item-id");
				if (!itemId) return;

				const currentQty = getItemQuantity(itemId) || 0;
				const newQty = currentQty + 1;

				if (currentQty === 0) {
					// Get item data from popup
					const popup = controls.closest(".popup-content");
					const itemTitle = popup?.querySelector("h3")?.textContent || "";
					const img = popup?.querySelector("img");
					const itemImage = img?.getAttribute("src") || img?.getAttribute("alt") || "";
					const deadlineEl = popup?.querySelector(".category");
					const itemDeadline = deadlineEl?.textContent || "";

					// Get max quantity from data attributes
					const quantityStr = controls.getAttribute("data-quantity") || "";
					const remainingStr = controls.getAttribute("data-remaining") || "";

					// Parse both limits
					const maxPerOrder = parseQuantityLimit(quantityStr);
					const remaining = parseInt(remainingStr, 10);

					// Calculate effective max: min of remaining and max per order
					let maxQuantity: number | null = null;
					if (!isNaN(remaining)) {
						maxQuantity = remaining;
						if (maxPerOrder !== null && maxPerOrder < remaining) {
							maxQuantity = maxPerOrder;
						}
					} else if (maxPerOrder !== null) {
						maxQuantity = maxPerOrder;
					}

					// Add item to cart with quantity 1
					addInterestedItem({
						id: itemId,
						title: itemTitle,
						category: "all",
						image: itemImage,
						deadline: itemDeadline,
						quantity: 1,
						maxQuantity: maxQuantity
					});
				} else {
					// Update existing quantity
					updateItemQuantity(itemId, newQty);
				}

				syncQuantityControls(itemId);
			}

			// Minus button
			if (target.closest(".quantity-btn.minus")) {
				e.preventDefault();
				e.stopPropagation();

				const btn = target.closest(".quantity-btn.minus") as HTMLButtonElement;
				const controls = btn.closest(".quantity-controls");
				if (!controls) return;

				const itemId = controls.getAttribute("data-item-id");
				if (!itemId) return;

				const currentQty = getItemQuantity(itemId) || 0;
				if (currentQty <= 0) return;

				const newQty = currentQty - 1;

				if (newQty === 0) {
					// Remove from cart when quantity reaches 0
					removeInterestedItem(itemId);
				} else {
					updateItemQuantity(itemId, newQty);
				}

				syncQuantityControls(itemId);
			}
		});

		// Listen to itemsChange events from localStorage
		window.addEventListener("itemsChange", function () {
			document.querySelectorAll(".quantity-controls").forEach(controls => {
				const itemId = controls.getAttribute("data-item-id");
				if (itemId) {
					syncQuantityControls(itemId);
				}
			});

			// Sync all sub-item controls
			document.querySelectorAll(".sub-item-controls").forEach(controls => {
				const subItemId = controls.getAttribute("data-sub-item-id");
				if (subItemId) {
					syncSubItemControls(subItemId);
				}
			});
		});

		// Initial sync on page load
		document.querySelectorAll(".quantity-controls").forEach(controls => {
			const itemId = controls.getAttribute("data-item-id");
			if (itemId) {
				syncQuantityControls(itemId);
			}
		});

		// Initial sync for sub-items on page load
		document.querySelectorAll(".sub-item-controls").forEach(controls => {
			const subItemId = controls.getAttribute("data-sub-item-id");
			if (subItemId) {
				syncSubItemControls(subItemId);
			}
		});
	});
</script>
